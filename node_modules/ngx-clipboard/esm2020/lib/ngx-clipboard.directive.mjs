import { Directive, EventEmitter, Input, Output } from '@angular/core';
import * as i0 from "@angular/core";
import * as i1 from "./ngx-clipboard.service";
export class ClipboardDirective {
    constructor(ngZone, host, renderer, clipboardSrv) {
        this.ngZone = ngZone;
        this.host = host;
        this.renderer = renderer;
        this.clipboardSrv = clipboardSrv;
        this.cbOnSuccess = new EventEmitter();
        this.cbOnError = new EventEmitter();
        this.onClick = (event) => {
            if (!this.clipboardSrv.isSupported) {
                this.handleResult(false, undefined, event);
            }
            else if (this.targetElm && this.clipboardSrv.isTargetValid(this.targetElm)) {
                this.handleResult(this.clipboardSrv.copyFromInputElement(this.targetElm), this.targetElm.value, event);
            }
            else if (this.cbContent) {
                this.handleResult(this.clipboardSrv.copyFromContent(this.cbContent, this.container), this.cbContent, event);
            }
        };
    }
    // eslint-disable-next-line no-empty, @typescript-eslint/no-empty-function
    ngOnInit() {
        this.ngZone.runOutsideAngular(() => {
            // By default each host listener schedules change detection and also wrapped
            // into additional function that calls `markForCheck()`. We're listening the `click`
            // event in the context of the root zone to avoid running unnecessary change detections,
            // since this directive doesn't do anything template-related (e.g. updates template variables).
            this.clickListener = this.renderer.listen(this.host.nativeElement, 'click', this.onClick);
        });
    }
    ngOnDestroy() {
        if (this.clickListener) {
            this.clickListener();
        }
        this.clipboardSrv.destroy(this.container);
    }
    /**
     * Fires an event based on the copy operation result.
     * @param succeeded
     */
    handleResult(succeeded, copiedContent, event) {
        let response = {
            isSuccess: succeeded,
            content: copiedContent,
            successMessage: this.cbSuccessMsg,
            event
        };
        if (succeeded) {
            if (this.cbOnSuccess.observed) {
                this.ngZone.run(() => {
                    this.cbOnSuccess.emit(response);
                });
            }
        }
        else {
            if (this.cbOnError.observed) {
                this.ngZone.run(() => {
                    this.cbOnError.emit(response);
                });
            }
        }
        this.clipboardSrv.pushCopyResponse(response);
    }
}
ClipboardDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.1.4", ngImport: i0, type: ClipboardDirective, deps: [{ token: i0.NgZone }, { token: i0.ElementRef }, { token: i0.Renderer2 }, { token: i1.ClipboardService }], target: i0.ɵɵFactoryTarget.Directive });
ClipboardDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "15.1.4", type: ClipboardDirective, selector: "[ngxClipboard]", inputs: { targetElm: ["ngxClipboard", "targetElm"], container: "container", cbContent: "cbContent", cbSuccessMsg: "cbSuccessMsg" }, outputs: { cbOnSuccess: "cbOnSuccess", cbOnError: "cbOnError" }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.1.4", ngImport: i0, type: ClipboardDirective, decorators: [{
            type: Directive,
            args: [{ selector: '[ngxClipboard]' }]
        }], ctorParameters: function () { return [{ type: i0.NgZone }, { type: i0.ElementRef }, { type: i0.Renderer2 }, { type: i1.ClipboardService }]; }, propDecorators: { targetElm: [{
                type: Input,
                args: ['ngxClipboard']
            }], container: [{
                type: Input
            }], cbContent: [{
                type: Input
            }], cbSuccessMsg: [{
                type: Input
            }], cbOnSuccess: [{
                type: Output
            }], cbOnError: [{
                type: Output
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmd4LWNsaXBib2FyZC5kaXJlY3RpdmUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9wcm9qZWN0cy9uZ3gtY2xpcGJvYXJkL3NyYy9saWIvbmd4LWNsaXBib2FyZC5kaXJlY3RpdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUNILFNBQVMsRUFFVCxZQUFZLEVBQ1osS0FBSyxFQUlMLE1BQU0sRUFFVCxNQUFNLGVBQWUsQ0FBQzs7O0FBS3ZCLE1BQU0sT0FBTyxrQkFBa0I7SUFzQjNCLFlBQ1ksTUFBYyxFQUNkLElBQTZCLEVBQzdCLFFBQW1CLEVBQ25CLFlBQThCO1FBSDlCLFdBQU0sR0FBTixNQUFNLENBQVE7UUFDZCxTQUFJLEdBQUosSUFBSSxDQUF5QjtRQUM3QixhQUFRLEdBQVIsUUFBUSxDQUFXO1FBQ25CLGlCQUFZLEdBQVosWUFBWSxDQUFrQjtRQVhuQyxnQkFBVyxHQUFxQyxJQUFJLFlBQVksRUFBc0IsQ0FBQztRQUd2RixjQUFTLEdBQXNCLElBQUksWUFBWSxFQUFPLENBQUM7UUE2QnRELFlBQU8sR0FBRyxDQUFDLEtBQWlCLEVBQVEsRUFBRTtZQUMxQyxJQUFJLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxXQUFXLEVBQUU7Z0JBQ2hDLElBQUksQ0FBQyxZQUFZLENBQUMsS0FBSyxFQUFFLFNBQVMsRUFBRSxLQUFLLENBQUMsQ0FBQzthQUM5QztpQkFBTSxJQUFJLElBQUksQ0FBQyxTQUFTLElBQUksSUFBSSxDQUFDLFlBQVksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxFQUFFO2dCQUMxRSxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsb0JBQW9CLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxFQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQyxDQUFDO2FBQzFHO2lCQUFNLElBQUksSUFBSSxDQUFDLFNBQVMsRUFBRTtnQkFDdkIsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsRUFBRSxJQUFJLENBQUMsU0FBUyxFQUFFLEtBQUssQ0FBQyxDQUFDO2FBQy9HO1FBQ0wsQ0FBQyxDQUFDO0lBNUJDLENBQUM7SUFFSiwwRUFBMEU7SUFDbkUsUUFBUTtRQUNYLElBQUksQ0FBQyxNQUFNLENBQUMsaUJBQWlCLENBQUMsR0FBRyxFQUFFO1lBQy9CLDRFQUE0RTtZQUM1RSxvRkFBb0Y7WUFDcEYsd0ZBQXdGO1lBQ3hGLCtGQUErRjtZQUMvRixJQUFJLENBQUMsYUFBYSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsYUFBYSxFQUFFLE9BQU8sRUFBRSxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDOUYsQ0FBQyxDQUFDLENBQUM7SUFDUCxDQUFDO0lBRU0sV0FBVztRQUNkLElBQUksSUFBSSxDQUFDLGFBQWEsRUFBRTtZQUNwQixJQUFJLENBQUMsYUFBYSxFQUFFLENBQUM7U0FDeEI7UUFDRCxJQUFJLENBQUMsWUFBWSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7SUFDOUMsQ0FBQztJQVlEOzs7T0FHRztJQUNLLFlBQVksQ0FBQyxTQUFrQixFQUFFLGFBQWlDLEVBQUUsS0FBaUI7UUFDekYsSUFBSSxRQUFRLEdBQXVCO1lBQy9CLFNBQVMsRUFBRSxTQUFTO1lBQ3BCLE9BQU8sRUFBRSxhQUFhO1lBQ3RCLGNBQWMsRUFBRSxJQUFJLENBQUMsWUFBWTtZQUNqQyxLQUFLO1NBQ1IsQ0FBQztRQUVGLElBQUksU0FBUyxFQUFFO1lBQ1gsSUFBSSxJQUFJLENBQUMsV0FBVyxDQUFDLFFBQVEsRUFBRTtnQkFDM0IsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFO29CQUNqQixJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztnQkFDcEMsQ0FBQyxDQUFDLENBQUM7YUFDTjtTQUNKO2FBQU07WUFDSCxJQUFJLElBQUksQ0FBQyxTQUFTLENBQUMsUUFBUSxFQUFFO2dCQUN6QixJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUU7b0JBQ2pCLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO2dCQUNsQyxDQUFDLENBQUMsQ0FBQzthQUNOO1NBQ0o7UUFFRCxJQUFJLENBQUMsWUFBWSxDQUFDLGdCQUFnQixDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ2pELENBQUM7OytHQXBGUSxrQkFBa0I7bUdBQWxCLGtCQUFrQjsyRkFBbEIsa0JBQWtCO2tCQUQ5QixTQUFTO21CQUFDLEVBQUUsUUFBUSxFQUFFLGdCQUFnQixFQUFFOzZLQUs5QixTQUFTO3NCQURmLEtBQUs7dUJBQUMsY0FBYztnQkFHZCxTQUFTO3NCQURmLEtBQUs7Z0JBSUMsU0FBUztzQkFEZixLQUFLO2dCQUlDLFlBQVk7c0JBRGxCLEtBQUs7Z0JBSUMsV0FBVztzQkFEakIsTUFBTTtnQkFJQSxTQUFTO3NCQURmLE1BQU0iLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICAgIERpcmVjdGl2ZSxcbiAgICBFbGVtZW50UmVmLFxuICAgIEV2ZW50RW1pdHRlcixcbiAgICBJbnB1dCxcbiAgICBOZ1pvbmUsXG4gICAgT25EZXN0cm95LFxuICAgIE9uSW5pdCxcbiAgICBPdXRwdXQsXG4gICAgUmVuZGVyZXIyXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgSUNsaXBib2FyZFJlc3BvbnNlIH0gZnJvbSAnLi9pbnRlcmZhY2UnO1xuaW1wb3J0IHsgQ2xpcGJvYXJkU2VydmljZSB9IGZyb20gJy4vbmd4LWNsaXBib2FyZC5zZXJ2aWNlJztcblxuQERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnW25neENsaXBib2FyZF0nIH0pXG5leHBvcnQgY2xhc3MgQ2xpcGJvYXJkRGlyZWN0aXZlIGltcGxlbWVudHMgT25Jbml0LCBPbkRlc3Ryb3kge1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXhpc2FtL25neC1jbGlwYm9hcmQvaXNzdWVzLzIzOSNpc3N1ZWNvbW1lbnQtNjIzMzMwNjI0XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEBhbmd1bGFyLWVzbGludC9uby1pbnB1dC1yZW5hbWVcbiAgICBASW5wdXQoJ25neENsaXBib2FyZCcpXG4gICAgcHVibGljIHRhcmdldEVsbTogSFRNTElucHV0RWxlbWVudCB8IEhUTUxUZXh0QXJlYUVsZW1lbnQgfCB1bmRlZmluZWQgfCAnJztcbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBjb250YWluZXI6IEhUTUxFbGVtZW50O1xuXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgY2JDb250ZW50OiBzdHJpbmcgfCB1bmRlZmluZWQ7XG5cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBjYlN1Y2Nlc3NNc2c6IHN0cmluZztcblxuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyBjYk9uU3VjY2VzczogRXZlbnRFbWl0dGVyPElDbGlwYm9hcmRSZXNwb25zZT4gPSBuZXcgRXZlbnRFbWl0dGVyPElDbGlwYm9hcmRSZXNwb25zZT4oKTtcblxuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyBjYk9uRXJyb3I6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG5cbiAgICBwcml2YXRlIGNsaWNrTGlzdGVuZXI6ICgpID0+IHZvaWQ7XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHJpdmF0ZSBuZ1pvbmU6IE5nWm9uZSxcbiAgICAgICAgcHJpdmF0ZSBob3N0OiBFbGVtZW50UmVmPEhUTUxFbGVtZW50PixcbiAgICAgICAgcHJpdmF0ZSByZW5kZXJlcjogUmVuZGVyZXIyLFxuICAgICAgICBwcml2YXRlIGNsaXBib2FyZFNydjogQ2xpcGJvYXJkU2VydmljZVxuICAgICkge31cblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lbXB0eSwgQHR5cGVzY3JpcHQtZXNsaW50L25vLWVtcHR5LWZ1bmN0aW9uXG4gICAgcHVibGljIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLm5nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICAvLyBCeSBkZWZhdWx0IGVhY2ggaG9zdCBsaXN0ZW5lciBzY2hlZHVsZXMgY2hhbmdlIGRldGVjdGlvbiBhbmQgYWxzbyB3cmFwcGVkXG4gICAgICAgICAgICAvLyBpbnRvIGFkZGl0aW9uYWwgZnVuY3Rpb24gdGhhdCBjYWxscyBgbWFya0ZvckNoZWNrKClgLiBXZSdyZSBsaXN0ZW5pbmcgdGhlIGBjbGlja2BcbiAgICAgICAgICAgIC8vIGV2ZW50IGluIHRoZSBjb250ZXh0IG9mIHRoZSByb290IHpvbmUgdG8gYXZvaWQgcnVubmluZyB1bm5lY2Vzc2FyeSBjaGFuZ2UgZGV0ZWN0aW9ucyxcbiAgICAgICAgICAgIC8vIHNpbmNlIHRoaXMgZGlyZWN0aXZlIGRvZXNuJ3QgZG8gYW55dGhpbmcgdGVtcGxhdGUtcmVsYXRlZCAoZS5nLiB1cGRhdGVzIHRlbXBsYXRlIHZhcmlhYmxlcykuXG4gICAgICAgICAgICB0aGlzLmNsaWNrTGlzdGVuZXIgPSB0aGlzLnJlbmRlcmVyLmxpc3Rlbih0aGlzLmhvc3QubmF0aXZlRWxlbWVudCwgJ2NsaWNrJywgdGhpcy5vbkNsaWNrKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHVibGljIG5nT25EZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5jbGlja0xpc3RlbmVyKSB7XG4gICAgICAgICAgICB0aGlzLmNsaWNrTGlzdGVuZXIoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsaXBib2FyZFNydi5kZXN0cm95KHRoaXMuY29udGFpbmVyKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIG9uQ2xpY2sgPSAoZXZlbnQ6IE1vdXNlRXZlbnQpOiB2b2lkID0+IHtcbiAgICAgICAgaWYgKCF0aGlzLmNsaXBib2FyZFNydi5pc1N1cHBvcnRlZCkge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVSZXN1bHQoZmFsc2UsIHVuZGVmaW5lZCwgZXZlbnQpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMudGFyZ2V0RWxtICYmIHRoaXMuY2xpcGJvYXJkU3J2LmlzVGFyZ2V0VmFsaWQodGhpcy50YXJnZXRFbG0pKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZVJlc3VsdCh0aGlzLmNsaXBib2FyZFNydi5jb3B5RnJvbUlucHV0RWxlbWVudCh0aGlzLnRhcmdldEVsbSksIHRoaXMudGFyZ2V0RWxtLnZhbHVlLCBldmVudCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5jYkNvbnRlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlUmVzdWx0KHRoaXMuY2xpcGJvYXJkU3J2LmNvcHlGcm9tQ29udGVudCh0aGlzLmNiQ29udGVudCwgdGhpcy5jb250YWluZXIpLCB0aGlzLmNiQ29udGVudCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEZpcmVzIGFuIGV2ZW50IGJhc2VkIG9uIHRoZSBjb3B5IG9wZXJhdGlvbiByZXN1bHQuXG4gICAgICogQHBhcmFtIHN1Y2NlZWRlZFxuICAgICAqL1xuICAgIHByaXZhdGUgaGFuZGxlUmVzdWx0KHN1Y2NlZWRlZDogYm9vbGVhbiwgY29waWVkQ29udGVudDogc3RyaW5nIHwgdW5kZWZpbmVkLCBldmVudDogTW91c2VFdmVudCk6IHZvaWQge1xuICAgICAgICBsZXQgcmVzcG9uc2U6IElDbGlwYm9hcmRSZXNwb25zZSA9IHtcbiAgICAgICAgICAgIGlzU3VjY2Vzczogc3VjY2VlZGVkLFxuICAgICAgICAgICAgY29udGVudDogY29waWVkQ29udGVudCxcbiAgICAgICAgICAgIHN1Y2Nlc3NNZXNzYWdlOiB0aGlzLmNiU3VjY2Vzc01zZyxcbiAgICAgICAgICAgIGV2ZW50XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHN1Y2NlZWRlZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2JPblN1Y2Nlc3Mub2JzZXJ2ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5nWm9uZS5ydW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNiT25TdWNjZXNzLmVtaXQocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2JPbkVycm9yLm9ic2VydmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZ1pvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYk9uRXJyb3IuZW1pdChyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNsaXBib2FyZFNydi5wdXNoQ29weVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICB9XG59XG4iXX0=